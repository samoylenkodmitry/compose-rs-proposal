//! Common rendering contracts shared between renderer backends.

use std::rc::Rc;

use compose_foundation::nodes::input::PointerEventKind;
use compose_ui_graphics::{DrawPrimitive, DrawScope, DrawScopeDefault, Rect, Size};

pub use compose_ui_graphics::Brush;

/// Trait implemented by hit-test targets stored inside a [`RenderScene`].
pub trait HitTestTarget {
    fn dispatch(&self, kind: PointerEventKind, x: f32, y: f32);
}

/// Trait describing the minimal surface area required by the application
/// shell to process pointer events and refresh the frame graph.
pub trait RenderScene {
    type HitTarget: HitTestTarget;

    fn clear(&mut self);
    fn hit_test(&self, x: f32, y: f32) -> Option<Self::HitTarget>;
}

/// Abstraction implemented by concrete renderer backends.
pub trait Renderer {
    type Scene: RenderScene;
    type Error;
    type Applier;
    type LayoutRoot;

    fn scene(&self) -> &Self::Scene;
    fn scene_mut(&mut self) -> &mut Self::Scene;

    fn rebuild_scene(
        &mut self,
        applier: &mut Self::Applier,
        root: &Self::LayoutRoot,
        viewport: Size,
    ) -> Result<(), Self::Error>;
}

pub type DrawCommandFn = Rc<dyn Fn(Size) -> Vec<DrawPrimitive>>;

#[derive(Clone)]
pub enum DrawCommand {
    Behind(DrawCommandFn),
    Overlay(DrawCommandFn),
}

#[derive(Clone, Debug, PartialEq)]
pub struct ImageHandle(pub u64);

#[derive(Clone, Debug, PartialEq)]
pub struct TextLayout {
    pub text: String,
    pub bounds: Rect,
}

impl TextLayout {
    pub fn new(text: impl Into<String>, bounds: Rect) -> Self {
        Self {
            text: text.into(),
            bounds,
        }
    }

    pub fn text(&self) -> &str {
        &self.text
    }

    pub fn bounds(&self) -> Rect {
        self.bounds
    }
}

/// Bundles the data generated by draw modifiers.
#[derive(Default, Clone)]
pub struct DrawCacheBuilder {
    behind: Vec<DrawCommandFn>,
    overlay: Vec<DrawCommandFn>,
}

impl DrawCacheBuilder {
    pub fn on_draw_behind(&mut self, f: impl Fn(&mut dyn DrawScope) + 'static) {
        let func = Rc::new(move |size: Size| {
            let mut scope = DrawScopeDefault::new(size);
            f(&mut scope);
            scope.into_primitives()
        });
        self.behind.push(func);
    }

    pub fn on_draw_with_content(&mut self, f: impl Fn(&mut dyn DrawScope) + 'static) {
        let func = Rc::new(move |size: Size| {
            let mut scope = DrawScopeDefault::new(size);
            f(&mut scope);
            scope.into_primitives()
        });
        self.overlay.push(func);
    }

    pub fn finish(self) -> Vec<DrawCommand> {
        let mut commands = Vec::new();
        commands.extend(self.behind.into_iter().map(DrawCommand::Behind));
        commands.extend(self.overlay.into_iter().map(DrawCommand::Overlay));
        commands
    }
}

/// Helper exposed for future scene composition backends. It converts
/// draw commands into primitives and pushes them into a [`RenderScene`].
pub fn execute_draw_commands(commands: &[DrawCommand], size: Size) -> Vec<DrawPrimitive> {
    let mut primitives = Vec::new();
    for command in commands {
        match command {
            DrawCommand::Behind(f) | DrawCommand::Overlay(f) => {
                primitives.extend(f(size).into_iter());
            }
        }
    }
    primitives
}
